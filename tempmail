\
#!/usr/bin/env python3
# TempMail.so CLI — minimal TUI with clipboard & robust drawing
# Commands:
#   tempmail create  [--minutes 10] [--prefix mybox] [--domain example.com]
#   tempmail delete
# Env:
#   RAPIDAPI_KEY, TEMPMAIL_TOKEN
import os, sys, time, json, random, string, re, argparse, curses, shutil, subprocess
from curses import textpad
from typing import Any, Dict, List
try:
    import requests
except Exception:
    print("Missing dependency 'requests'. Install with: pip install requests or apt install python3-requests", file=sys.stderr)
    sys.exit(1)

BASE = "https://tempmail-so.p.rapidapi.com"
STATE_PATH = os.path.expanduser("~/.tempmail_state.json")

def headers() -> Dict[str,str]:
    rk = os.getenv("RAPIDAPI_KEY")
    tk = os.getenv("TEMPMAIL_TOKEN")
    if not rk or not tk:
        print("Set RAPIDAPI_KEY and TEMPMAIL_TOKEN environment variables.", file=sys.stderr)
        sys.exit(2)
    return {"x-rapidapi-key": rk, "Authorization": f"Bearer {tk}"}

def api(method: str, path: str, **kwargs):
    url = f"{BASE}{path}"
    h = kwargs.pop("headers", {})
    h.update(headers())
    try:
        r = requests.request(method, url, headers=h, timeout=30, **kwargs)
    except requests.RequestException as e:
        raise SystemExit(f"Network error: {e}")
    if not r.ok:
        t = (r.text or r.reason)
        raise SystemExit(f"HTTP {r.status_code}: {t[:400]}")
    try:
        return r.json()
    except Exception:
        return {"raw": r.text}

def list_domains() -> List[str]:
    out = api("GET", "/domains")
    data = out.get("data", out)
    names = []
    for item in data:
        names.append(item.get("name") or item.get("domain"))
    return [n for n in names if n]

def random_prefix(n=7) -> str:
    return "tm" + "".join(random.choices(string.ascii_lowercase + string.digits, k=n))

def minutes_to_seconds(m) -> int:
    if m is None:
        return 600  # default 10 minutes
    try:
        m = float(m)
    except ValueError:
        raise SystemExit("Invalid --minutes value")
    if m < 0:
        raise SystemExit("--minutes cannot be negative")
    return int(round(m * 60))

def create_inbox(prefix=None, domain=None, minutes=None):
    if not domain:
        domains = list_domains()
        if not domains:
            raise SystemExit("No domains available from API.")
        domain = domains[0]
    if not prefix:
        prefix = random_prefix()
    lifespan = minutes_to_seconds(minutes)
    form = {"address": prefix, "name": prefix, "domain": domain, "lifespan": str(lifespan)}
    out = api("POST", "/inboxes", data=form, headers={"Content-Type": "application/x-www-form-urlencoded"})
    data = out.get("data", out)
    inbox_id = data.get("id")
    email = f"{prefix}@{domain}"
    if not inbox_id:
        raise SystemExit("Failed to create inbox (missing id).")
    state = {"inbox_id": inbox_id, "email": email, "created": int(time.time())}
    try:
        with open(STATE_PATH, "w", encoding="utf-8") as f:
            json.dump(state, f)
    except Exception as e:
        print(f"Warning: couldn't write state file {STATE_PATH}: {e}", file=sys.stderr)
    return state

def delete_inbox(state=None):
    if state is None:
        try:
            with open(STATE_PATH, "r", encoding="utf-8") as f:
                state = json.load(f)
        except Exception:
            raise SystemExit("No state found. Create an inbox first with: tempmail create")
    iid = state.get("inbox_id")
    if not iid:
        raise SystemExit("State file is missing inbox_id.")
    api("DELETE", f"/inboxes/{iid}")
    try:
        os.remove(STATE_PATH)
    except Exception:
        pass
    return iid

def list_mails(inbox_id: str) -> List[Dict[str, Any]]:
    out = api("GET", f"/inboxes/{inbox_id}/mails")
    payload = out.get("data", out)
    data: List[Dict[str,Any]] = []
    if isinstance(payload, list):
        data = payload
    elif isinstance(payload, dict):
        for k in ("mails","items","rows","list","data"):
            v = payload.get(k)
            if isinstance(v, list):
                data = v
                break
        if not data:
            for v in payload.values():
                if isinstance(v, list):
                    data = v
                    break
    for m in data:
        m.setdefault("subject", m.get("subject") or m.get("title") or "")
        m.setdefault("from", m.get("from") or m.get("sender") or "")
        m.setdefault("received", m.get("received") or m.get("date") or "")
        m.setdefault("id", m.get("id") or m.get("_id"))
    return data

def read_mail(inbox_id: str, mail_id: str) -> Dict[str, Any]:
    out = api("GET", f"/inboxes/{inbox_id}/mails/{mail_id}")
    data = out.get("data", out)
    return data

def strip_html(html: str) -> str:
    if not html:
        return ""
    text = re.sub(r"<br\\s*/?>", "\\n", html, flags=re.I)
    text = re.sub(r"</p>", "\\n\\n", text, flags=re.I)
    text = re.sub(r"<[^>]+>", "", text)
    return re.sub(r"\\n{3,}", "\\n\\n", text).strip()

def copy_to_clipboard(text: str) -> bool:
    # macOS
    if shutil.which("pbcopy"):
        try:
            subprocess.run(["pbcopy"], input=text.encode(), check=True)
            return True
        except Exception:
            pass
    # Windows / WSL
    for clip in ("clip.exe", "/mnt/c/Windows/System32/clip.exe"):
        if shutil.which(clip) or os.path.exists(clip):
            try:
                subprocess.run([clip], input=(text + "\\r\\n").encode("utf-16le"), check=True)
                return True
            except Exception:
                pass
    # Wayland
    if shutil.which("wl-copy"):
        try:
            subprocess.run(["wl-copy"], input=text.encode(), check=True)
            return True
        except Exception:
            pass
    # X11
    if shutil.which("xclip"):
        try:
            subprocess.run(["xclip", "-selection", "clipboard"], input=text.encode(), check=True)
            return True
        except Exception:
            pass
    if shutil.which("xsel"):
        try:
            subprocess.run(["xsel", "--clipboard", "--input"], input=text.encode(), check=True)
            return True
        except Exception:
            pass
    return False

# ---- Safe drawing helpers ----
def clamp_width(w: int) -> int:
    return max(1, w-1)  # leave last col free

def safe_addnstr(win, y: int, x: int, s: str, w: int, attr=0):
    try:
        h, ww = win.getmaxyx()
        if y < 0 or y >= h or x < 0 or x >= ww:
            return
        maxw = min(clamp_width(ww - x), w)
        if maxw <= 0:
            return
        win.addnstr(y, x, (s or "")[:maxw], maxw, attr)
    except curses.error:
        pass

def safe_clear_line(win, y: int):
    try:
        h, w = win.getmaxyx()
        if 0 <= y < h:
            win.move(y, 0)
            win.clrtoeol()
    except curses.error:
        pass

class InboxUI:
    def __init__(self, inbox_id: str, email: str, poll: float = 2.0):
        self.inbox_id = inbox_id
        self.email = email
        self.poll = poll
        self.mails: List[Dict[str,Any]] = []
        self.selected = 0
        self.last_fetch = 0.0
        self.preview_cache: Dict[str, Dict[str,str]] = {}
        self.flash_until = 0.0
        self.flash_text = ""

    def fetch(self):
        ms = list_mails(self.inbox_id)
        if not isinstance(ms, list):  # ultra defensive
            ms = []
        self.mails = ms
        self.last_fetch = time.time()

    def set_flash(self, text: str, seconds: float = 2.0):
        self.flash_text = text
        self.flash_until = time.time() + seconds

    def draw(self, stdscr):
        stdscr.clear()
        h, w = stdscr.getmaxyx()

        title = f"TempMail: {self.email}   (q=quit, Enter=open, r=refresh, d=delete inbox, c=copy address)"
        safe_addnstr(stdscr, 0, 0, title.ljust(w), w, curses.A_REVERSE)

        list_w = max(30, int(w * 0.45))
        preview_x = list_w + 1

        # frames
        try:
            textpad.rectangle(stdscr, 1, 0, max(2, h-2), min(list_w, w-2))
            textpad.rectangle(stdscr, 1, min(preview_x, w-2), max(2, h-2), w-1)
        except curses.error:
            pass

        safe_addnstr(stdscr, 1, 2, "Inbox", w)
        safe_addnstr(stdscr, 1, preview_x+2, "Preview", w)

        # list entries
        max_rows = max(0, h - 4)
        for i, m in enumerate(self.mails[:max_rows]):
            y = 2 + i
            subj = (m.get("subject") or "(no subject)").replace("\\n", " ")
            frm = (m.get("from") or "").replace("\\n", " ")
            line = f"{i+1:>2}. {subj[:list_w-10]}  ← {frm[:list_w//2]}"
            attr = curses.A_REVERSE if i == self.selected else curses.A_NORMAL
            safe_addnstr(stdscr, y, 1, line.ljust(list_w-1), list_w-1, attr)

        # preview
        if self.mails:
            sel = self.mails[self.selected]
            mid = sel.get("id")
            cached = self.preview_cache.get(mid)
            if not cached:
                full = read_mail(self.inbox_id, mid)
                text = full.get("textContent") or strip_html(full.get("htmlContent") or "")
                cached = {
                    "subject": full.get("subject") or sel.get("subject") or "(no subject)",
                    "from": full.get("from") or sel.get("from") or "",
                    "date": full.get("received") or sel.get("received") or "",
                    "body": text if text else "(no content)"
                }
                self.preview_cache[mid] = cached

            header_lines = [
                f"From: {cached['from']}",
                f"Subject: {cached['subject']}",
                (f"Date: {cached['date']}" if cached.get("date") else ""),
                "-" * max(10, (w - preview_x - 4))
            ]
            p_w = max(1, (w-2) - (preview_x+1))
            y = 2
            for ln in header_lines:
                if not ln: 
                    continue
                safe_addnstr(stdscr, y, preview_x+1, ln, p_w, curses.A_BOLD)
                y += 1
                if y >= h-2: break

            if y < h-2:
                for para in cached["body"].splitlines()[:1000]:
                    while para:
                        safe_addnstr(stdscr, y, preview_x+1, para, p_w)
                        para = para[p_w:]
                        y += 1
                        if y >= h-2: break
                    if y >= h-2: break

        # footer flash
        if time.time() < self.flash_until:
            safe_clear_line(stdscr, h-1)
            safe_addnstr(stdscr, h-1, 0, self.flash_text, w, curses.A_BOLD)

        stdscr.refresh()

    def run(self, stdscr):
        curses.curs_set(0)
        stdscr.keypad(True)
        curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        stdscr.timeout(250)
        self.fetch()
        self.set_flash("Press 'c' to copy this address to clipboard")
        while True:
            if time.time() - self.last_fetch >= self.poll:
                try:
                    self.fetch()
                except SystemExit as e:
                    h, w = stdscr.getmaxyx()
                    safe_addnstr(stdscr, h-1, 0, f"Poll error: {e}", w, curses.A_BOLD)
                    stdscr.refresh()
                self.draw(stdscr)
            else:
                self.draw(stdscr)

            ch = stdscr.getch()
            if ch == -1:
                continue
            if ch in (ord('q'), 27):
                break
            if ch in (curses.KEY_UP, ord('k')):
                if self.selected > 0:
                    self.selected -= 1
            elif ch in (curses.KEY_DOWN, ord('j')):
                if self.selected < max(0, len(self.mails)-1):
                    self.selected += 1
            elif ch == ord('r'):
                self.fetch()
            elif ch == ord('d'):
                if confirm_dialog(stdscr, "Delete this inbox? (y/N)"):
                    raise KeyboardInterrupt("DELETE_INBOX")
            elif ch == ord('c'):
                ok = copy_to_clipboard(self.email)
                self.set_flash("Address copied to clipboard" if ok else "Copy failed — install xclip/wl-copy or use Windows clip.exe")
            elif ch == curses.KEY_MOUSE:
                try:
                    _, mx, my, _, _ = curses.getmouse()
                    h, w = stdscr.getmaxyx()
                    list_w = max(30, int(w * 0.45))
                    if 2 <= my <= (h-3) and 1 <= mx <= list_w-1:
                        idx = my - 2
                        if 0 <= idx < len(self.mails):
                            self.selected = idx
                except Exception:
                    pass
            elif ch in (curses.KEY_ENTER, 10, 13):
                if self.mails:
                    mid = self.mails[self.selected].get("id")
                    if mid:
                        self.preview_cache.pop(mid, None)

def confirm_dialog(stdscr, message: str) -> bool:
    h, w = stdscr.getmaxyx()
    box_w = min(len(message)+6, max(10, w-4))
    box_h = 5
    y0 = max(0, (h - box_h) // 2)
    x0 = max(0, (w - box_w) // 2)
    try:
        win = curses.newwin(box_h, box_w, y0, x0)
        textpad.rectangle(stdscr, y0-1, x0-1, y0+box_h, x0+box_w)
        safe_addnstr(win, 1, 2, message, box_w-4)
        safe_addnstr(win, 3, 2, "[y] Yes   [n] No", box_w-4)
        stdscr.refresh()
        win.refresh()
    except curses.error:
        pass
    while True:
        ch = stdscr.getch()
        if ch in (ord('y'), ord('Y')): return True
        if ch in (ord('n'), ord('N'), 27): return False

def read_state():
    try:
        with open(STATE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def cmd_create(args):
    state = create_inbox(prefix=args.prefix, domain=args.domain, minutes=args.minutes)
    email = state["email"]
    iid = state["inbox_id"]
    print(f"Created inbox: {email}  (id={iid})")
    if copy_to_clipboard(email):
        print("Copied address to clipboard.")
    print("Opening live view… (q to quit, d to delete inbox, c=copy address)")
    ui = InboxUI(iid, email, poll=max(1.0, float(args.interval)))
    try:
        curses.wrapper(ui.run)
    except KeyboardInterrupt as e:
        if str(e) == "DELETE_INBOX":
            api("DELETE", f"/inboxes/{iid}")
            try: os.remove(STATE_PATH)
            except Exception: pass
            print("\\nInbox deleted.")
        else:
            print("\\nInterrupted.")

def cmd_delete(_args):
    st = read_state()
    if not st:
        print("No last-created inbox found in state.", file=sys.stderr)
        sys.exit(3)
    iid = delete_inbox(st)
    print(f"Deleted inbox id={iid}")

def build_parser():
    p = argparse.ArgumentParser(prog="tempmail", description="Simple TempMail.so CLI")
    sub = p.add_subparsers(dest="cmd")

    sp = sub.add_parser("create", help="Create inbox and open live view")
    sp.add_argument("--minutes", "-m", type=float, default=10, help="lifespan in minutes (default 10)")
    sp.add_argument("--prefix", "-p", help="local-part (random if omitted)")
    sp.add_argument("--domain", "-d", help="domain (first available if omitted)")
    sp.add_argument("--interval", "-t", type=float, default=2, help="poll seconds for live view (default 2)")
    sp.set_defaults(func=cmd_create)

    sp = sub.add_parser("delete", help="Delete last-created inbox")
    sp.set_defaults(func=cmd_delete)
    return p

def main():
    parser = build_parser()
    args = parser.parse_args()
    if not args.cmd:
        parser.print_help(sys.stderr); sys.exit(1)
    args.func(args)

if __name__ == "__main__":
    main()
